{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83d\udce6 Semantic Backup Explorer","text":"<p>Ein Python-basiertes Tool zur Synchronisation, Analyse und semantischen Durchsuchung von Backups auf externen Festplatten.</p> <p>Der Semantic Backup Explorer hilft dir dabei, den \u00dcberblick \u00fcber deine verstreuten Backups auf verschiedenen externen Laufwerken zu behalten. Der Fokus liegt auf einem einfachen One-Click Sync, um deine t\u00e4gliche Arbeit schnell und unkompliziert zu sichern. Optional kannst du modernste KI-Technologie (Large Language Models) nutzen, um deine Dateien auffindbar zu machen.</p>"},{"location":"#warum-semantic-backup-explorer","title":"\ud83e\udd14 Warum Semantic Backup Explorer?","text":"<p>Hast du mehrere externe Festplatten und m\u00f6chtest sicherstellen, dass dein aktuelles Projekt auf dem richtigen Backup-Stand ist? Oder suchst du verzweifelt nach Dateien, ohne jede Platte einzeln anschlie\u00dfen zu wollen?</p> <p>Hier kommt der Semantic Backup Explorer ins Spiel:</p> <ol> <li>Blitzschneller Abgleich (One-Click Sync): W\u00e4hle einen lokalen Ordner, und die App findet automatisch das passende Backup-Gegenst\u00fcck und zeigt dir, was fehlt.</li> <li>Kompakter Index: Die App speichert die Struktur deiner Festplatte in einer kleinen Textdatei. So wei\u00dft du immer, was wo liegt, auch wenn die Platte im Schrank liegt.</li> <li>KI-Suche (Optional): Die KI versteht Zusammenh\u00e4nge (z.B. findet sie \"Rechnungen\", wenn du nach \"Finanzen\" suchst) und hilft dir, den richtigen Backup-Ordner zu finden.</li> </ol>"},{"location":"#hauptfunktionen","title":"\ud83c\udf1f Hauptfunktionen","text":"<ul> <li>\ud83d\udd04 One-Click Sync: Kopiere fehlende oder neuere Dateien mit nur einem Klick auf dein Backup-Laufwerk.</li> <li>\ud83d\udcc2 Intelligenter Abgleich: Findet automatisch den richtigen Zielordner auf deinem Backup.</li> <li>\ud83d\udd0d Semantische Suche (Optional): Frage einfach: \"Wo habe ich meine Python-Projekte gesichert?\"</li> <li>\ud83c\udff7\ufe0f Laufwerks-Erkennung: Erkennt automatisch den Namen (Label) deiner Festplatten unter Windows.</li> </ul>"},{"location":"#schnellstart-5-minuten","title":"\ud83d\ude80 Schnellstart (5 Minuten)","text":""},{"location":"#1-installation","title":"1. Installation","text":"<p>Basis (Sync &amp; Index): <pre><code>git clone https://github.com/dgaida/semantic-backup-explorer.git\ncd semantic-backup-explorer\npip install -e .\n</code></pre></p> <p>Optional (Semantische Suche): <pre><code>pip install -e \".[semantic]\"\ncp .env.example .env\n# Trage deinen GROQ_API_KEY in .env ein\n</code></pre></p>"},{"location":"#2-web-app-starten","title":"2. Web-App starten","text":"<p><pre><code>python -m semantic_backup_explorer.cli.ui.gradio_app\n</code></pre> \u00d6ffne http://localhost:7860 und starte deinen ersten Sync!</p>"},{"location":"#architektur","title":"\ud83c\udfd7 Architektur","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Gradio Web UI  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Sync &amp; Compare  \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2524 Backup Index \u2502\n\u2502 (Core Logic)    \u2502      \u2502 (Markdown)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 (Optional)\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 RAG Pipeline    \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2524  ChromaDB    \u2502\n\u2502 (Semantic)      \u2502      \u2502  (Embeddings)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#projektstruktur","title":"\ud83d\udcc1 Projektstruktur","text":"<pre><code>semantic_backup_explorer/\n\u251c\u2500\u2500 cli/            # CLI-spezifische Logik &amp; UI\n\u2502   \u251c\u2500\u2500 commands/   # Zuk\u00fcnftige CLI Commands\n\u2502   \u2514\u2500\u2500 ui/         # Gradio Web Interface\n\u251c\u2500\u2500 core/           # Kern-Businesslogik (BackupOperations)\n\u251c\u2500\u2500 indexer/        # Scanning-Logik\n\u251c\u2500\u2500 chunking/       # Markdown Partitionierung\n\u251c\u2500\u2500 rag/            # Embedding &amp; Retrieval\n\u251c\u2500\u2500 compare/        # Folder Diffing\n\u251c\u2500\u2500 sync/           # Datei Synchronisation\n\u251c\u2500\u2500 utils/          # Hilfsfunktionen (Config, Logging, Paths)\n\u2514\u2500\u2500 exceptions.py   # Custom Exceptions\n</code></pre>"},{"location":"#kernfunktionen","title":"\u2699\ufe0f Kernfunktionen","text":"<ul> <li>\ud83d\udd04 One-Click Sync: Kopiere fehlende oder neuere Dateien mit nur einem Klick auf dein Backup-Laufwerk.</li> <li>\ud83d\udcc4 Backup-Index: Erfasse die Struktur deiner Backup-Laufwerke als kompakte Markdown-Datei.</li> <li>\ud83d\udd0d Semantische Suche (Optional): Nutze KI (LLMs), um deine Backups in nat\u00fcrlicher Sprache zu durchsuchen.</li> </ul>"},{"location":"#troubleshooting","title":"\u2753 Troubleshooting","text":""},{"location":"#groq_api_key-nicht-gefunden","title":"\"GROQ_API_KEY nicht gefunden\"","text":"<p>Stelle sicher, dass die <code>.env</code> Datei im Root-Verzeichnis existiert und einen g\u00fcltigen API-Key enth\u00e4lt: <pre><code>echo \"GROQ_API_KEY=gsk_xxx\" &gt; .env\n</code></pre></p>"},{"location":"#python-314-nicht-unterstutzt","title":"\"Python 3.14+ nicht unterst\u00fctzt\"","text":"<p>Das Projekt nutzt ChromaDB, welches aktuell Inkompatibilit\u00e4ten mit Python 3.14+ aufweist. Nutze Python 3.10-3.13.</p>"},{"location":"#entwicklung","title":"\ud83d\udee0 Entwicklung","text":"<p>Details zur Entwicklung, Testing und CI/CD findest du in der CONTRIBUTING.md. Detailed documentation is available in the <code>docs/</code> folder.</p>"},{"location":"#tests-ausfuhren","title":"Tests ausf\u00fchren","text":"<pre><code>pytest\n</code></pre>"},{"location":"#lizenz","title":"\ud83d\udcdc Lizenz","text":"<p>MIT License</p>"},{"location":"api/","title":"API Reference","text":"<p>This page contains the automatically generated API documentation for the Semantic Backup Explorer.</p>"},{"location":"api/#semantic_backup_explorer.core.backup_operations","title":"<code>semantic_backup_explorer.core.backup_operations</code>","text":"<p>Core business logic for backup operations.</p>"},{"location":"api/#semantic_backup_explorer.core.backup_operations-classes","title":"Classes","text":""},{"location":"api/#semantic_backup_explorer.core.backup_operations.BackupComparisonResult","title":"<code>BackupComparisonResult</code>  <code>dataclass</code>","text":"<p>Result of comparing a local folder with its backup.</p> Source code in <code>semantic_backup_explorer/core/backup_operations.py</code> <pre><code>@dataclass\nclass BackupComparisonResult:\n    \"\"\"Result of comparing a local folder with its backup.\"\"\"\n\n    local_path: Path\n    backup_path: Optional[Path]\n    only_local: list[str]\n    only_backup: list[str]\n    in_both: list[str]\n    error: Optional[str] = None\n</code></pre>"},{"location":"api/#semantic_backup_explorer.core.backup_operations.BackupOperations","title":"<code>BackupOperations</code>","text":"<p>High-level operations for backup management.</p> Source code in <code>semantic_backup_explorer/core/backup_operations.py</code> <pre><code>class BackupOperations:\n    \"\"\"High-level operations for backup management.\"\"\"\n\n    def __init__(self, index_path: Path, rag_pipeline: Optional[\"RAGPipeline\"] = None):\n        \"\"\"\n        Initialize BackupOperations.\n\n        Args:\n            index_path: Path to the backup index file.\n            rag_pipeline: Optional RAG pipeline for semantic folder matching.\n        \"\"\"\n        self.index_path = index_path\n        self.rag_pipeline = rag_pipeline\n\n    def verify_backup_drive(self) -&gt; tuple[bool, Optional[str]]:\n        \"\"\"\n        Verifies if the currently connected drive matches the one in the index.\n\n        Returns:\n            A tuple of (is_correct, error_message).\n        \"\"\"\n        metadata = get_index_metadata(self.index_path)\n        if not metadata.root_path:\n            return False, \"Kein g\u00fcltiger Index gefunden.\"\n\n        if not metadata.root_path.exists():\n            return False, f\"Das Backup-Laufwerk ({metadata.root_path}) ist nicht angeschlossen.\"\n\n        if metadata.label:\n            current_label = get_volume_label(metadata.root_path)\n            if current_label and current_label != metadata.label:\n                return (\n                    False,\n                    f\"Laufwerks-Konflikt! Erwartetes Label: '{metadata.label}', \"\n                    f\"Gefundenes Label: '{current_label}'. \"\n                    \"Bitte schlie\u00dfe das richtige Laufwerk an oder erstelle einen neuen Index.\",\n                )\n\n        return True, None\n\n    def find_and_compare(self, local_path: Path) -&gt; BackupComparisonResult:\n        \"\"\"\n        Finds the matching backup folder and compares contents.\n\n        Args:\n            local_path: The local folder to compare.\n\n        Returns:\n            A BackupComparisonResult object.\n        \"\"\"\n        # First verify the drive\n        is_correct, error = self.verify_backup_drive()\n        if not is_correct:\n            return BackupComparisonResult(\n                local_path=local_path,\n                backup_path=None,\n                only_local=[],\n                only_backup=[],\n                in_both=[],\n                error=error,\n            )\n\n        if not local_path.exists():\n            return BackupComparisonResult(\n                local_path=local_path,\n                backup_path=None,\n                only_local=[],\n                only_backup=[],\n                in_both=[],\n                error=f\"Local path does not exist: {local_path}\",\n            )\n\n        folder_name = local_path.name or str(local_path)\n        backup_folder_str = find_backup_folder(folder_name, self.index_path)\n\n        # Fallback to RAG if enabled and no direct match found\n        if not backup_folder_str and self.rag_pipeline is not None:\n            logger.info(f\"No direct match for {folder_name}, trying RAG search...\")\n            backup_folder_str = self._rag_search(folder_name)\n\n        if not backup_folder_str:\n            return BackupComparisonResult(\n                local_path=local_path,\n                backup_path=None,\n                only_local=[],  # Could potentially list all local files here\n                only_backup=[],\n                in_both=[],\n                error=f\"No matching backup folder found for {folder_name}\",\n            )\n\n        backup_path = Path(backup_folder_str)\n        backup_files = get_all_files_from_index(backup_folder_str, self.index_path)\n        diff: FolderDiffResult = compare_folders(local_path, backup_files)\n\n        return BackupComparisonResult(\n            local_path=local_path,\n            backup_path=backup_path,\n            only_local=diff[\"only_local\"],\n            only_backup=diff[\"only_backup\"],\n            in_both=diff[\"in_both\"],\n        )\n\n    def _rag_search(self, folder_name: str) -&gt; Optional[str]:\n        \"\"\"\n        Search for a folder using the RAG pipeline.\n\n        Args:\n            folder_name: The folder name to search for.\n\n        Returns:\n            The path of the most likely matching folder, or None.\n        \"\"\"\n        if not self.rag_pipeline:\n            return None\n\n        try:\n            # We ask the RAG pipeline specifically for the path\n            question = f\"In welchem Ordner im Backup befinden sich die Dateien f\u00fcr '{folder_name}'? Nenne nur den Pfad.\"\n            answer, _ = self.rag_pipeline.answer_question(question)\n\n            # Simple extraction from answer\n            potential_path = answer.strip().split(\"\\n\")[0].strip()\n            if potential_path.startswith(\"## \"):\n                potential_path = potential_path[3:]\n\n            if \"/\" in potential_path or \"\\\\\" in potential_path:\n                return potential_path\n        except Exception as e:\n            logger.error(f\"Error during RAG search for folder: {e}\")\n\n        return None\n</code></pre>"},{"location":"api/#semantic_backup_explorer.core.backup_operations.BackupOperations-functions","title":"Functions","text":""},{"location":"api/#semantic_backup_explorer.core.backup_operations.BackupOperations.__init__","title":"<code>__init__(index_path, rag_pipeline=None)</code>","text":"<p>Initialize BackupOperations.</p> <p>Parameters:</p> Name Type Description Default <code>index_path</code> <code>Path</code> <p>Path to the backup index file.</p> required <code>rag_pipeline</code> <code>Optional[RAGPipeline]</code> <p>Optional RAG pipeline for semantic folder matching.</p> <code>None</code> Source code in <code>semantic_backup_explorer/core/backup_operations.py</code> <pre><code>def __init__(self, index_path: Path, rag_pipeline: Optional[\"RAGPipeline\"] = None):\n    \"\"\"\n    Initialize BackupOperations.\n\n    Args:\n        index_path: Path to the backup index file.\n        rag_pipeline: Optional RAG pipeline for semantic folder matching.\n    \"\"\"\n    self.index_path = index_path\n    self.rag_pipeline = rag_pipeline\n</code></pre>"},{"location":"api/#semantic_backup_explorer.core.backup_operations.BackupOperations.find_and_compare","title":"<code>find_and_compare(local_path)</code>","text":"<p>Finds the matching backup folder and compares contents.</p> <p>Parameters:</p> Name Type Description Default <code>local_path</code> <code>Path</code> <p>The local folder to compare.</p> required <p>Returns:</p> Type Description <code>BackupComparisonResult</code> <p>A BackupComparisonResult object.</p> Source code in <code>semantic_backup_explorer/core/backup_operations.py</code> <pre><code>def find_and_compare(self, local_path: Path) -&gt; BackupComparisonResult:\n    \"\"\"\n    Finds the matching backup folder and compares contents.\n\n    Args:\n        local_path: The local folder to compare.\n\n    Returns:\n        A BackupComparisonResult object.\n    \"\"\"\n    # First verify the drive\n    is_correct, error = self.verify_backup_drive()\n    if not is_correct:\n        return BackupComparisonResult(\n            local_path=local_path,\n            backup_path=None,\n            only_local=[],\n            only_backup=[],\n            in_both=[],\n            error=error,\n        )\n\n    if not local_path.exists():\n        return BackupComparisonResult(\n            local_path=local_path,\n            backup_path=None,\n            only_local=[],\n            only_backup=[],\n            in_both=[],\n            error=f\"Local path does not exist: {local_path}\",\n        )\n\n    folder_name = local_path.name or str(local_path)\n    backup_folder_str = find_backup_folder(folder_name, self.index_path)\n\n    # Fallback to RAG if enabled and no direct match found\n    if not backup_folder_str and self.rag_pipeline is not None:\n        logger.info(f\"No direct match for {folder_name}, trying RAG search...\")\n        backup_folder_str = self._rag_search(folder_name)\n\n    if not backup_folder_str:\n        return BackupComparisonResult(\n            local_path=local_path,\n            backup_path=None,\n            only_local=[],  # Could potentially list all local files here\n            only_backup=[],\n            in_both=[],\n            error=f\"No matching backup folder found for {folder_name}\",\n        )\n\n    backup_path = Path(backup_folder_str)\n    backup_files = get_all_files_from_index(backup_folder_str, self.index_path)\n    diff: FolderDiffResult = compare_folders(local_path, backup_files)\n\n    return BackupComparisonResult(\n        local_path=local_path,\n        backup_path=backup_path,\n        only_local=diff[\"only_local\"],\n        only_backup=diff[\"only_backup\"],\n        in_both=diff[\"in_both\"],\n    )\n</code></pre>"},{"location":"api/#semantic_backup_explorer.core.backup_operations.BackupOperations.verify_backup_drive","title":"<code>verify_backup_drive()</code>","text":"<p>Verifies if the currently connected drive matches the one in the index.</p> <p>Returns:</p> Type Description <code>tuple[bool, Optional[str]]</code> <p>A tuple of (is_correct, error_message).</p> Source code in <code>semantic_backup_explorer/core/backup_operations.py</code> <pre><code>def verify_backup_drive(self) -&gt; tuple[bool, Optional[str]]:\n    \"\"\"\n    Verifies if the currently connected drive matches the one in the index.\n\n    Returns:\n        A tuple of (is_correct, error_message).\n    \"\"\"\n    metadata = get_index_metadata(self.index_path)\n    if not metadata.root_path:\n        return False, \"Kein g\u00fcltiger Index gefunden.\"\n\n    if not metadata.root_path.exists():\n        return False, f\"Das Backup-Laufwerk ({metadata.root_path}) ist nicht angeschlossen.\"\n\n    if metadata.label:\n        current_label = get_volume_label(metadata.root_path)\n        if current_label and current_label != metadata.label:\n            return (\n                False,\n                f\"Laufwerks-Konflikt! Erwartetes Label: '{metadata.label}', \"\n                f\"Gefundenes Label: '{current_label}'. \"\n                \"Bitte schlie\u00dfe das richtige Laufwerk an oder erstelle einen neuen Index.\",\n            )\n\n    return True, None\n</code></pre>"},{"location":"api/#semantic_backup_explorer.core.backup_operations-functions","title":"Functions","text":""},{"location":"api/#semantic_backup_explorer.indexer.scan_backup","title":"<code>semantic_backup_explorer.indexer.scan_backup</code>","text":"<p>Module for scanning backup directories and creating a markdown index.</p>"},{"location":"api/#semantic_backup_explorer.indexer.scan_backup-functions","title":"Functions","text":""},{"location":"api/#semantic_backup_explorer.indexer.scan_backup.scan_backup","title":"<code>scan_backup(root_path, output_file='data/backup_index.md', callback=None)</code>","text":"<p>Recursively scans the root_path and writes every file and folder with its full path into a structured markdown file.</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>str | Path</code> <p>Path to the backup directory to scan.</p> required <code>output_file</code> <code>str | Path</code> <p>Path to the output markdown file.</p> <code>'data/backup_index.md'</code> <code>callback</code> <code>Optional[Callable[[int, str], None]]</code> <p>Optional callback function called with (count, current_root).</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If root_path does not exist.</p> <code>NotADirectoryError</code> <p>If root_path is not a directory.</p> <code>PermissionError</code> <p>If output_file cannot be written.</p> Source code in <code>semantic_backup_explorer/indexer/scan_backup.py</code> <pre><code>def scan_backup(\n    root_path: str | Path,\n    output_file: str | Path = \"data/backup_index.md\",\n    callback: Optional[Callable[[int, str], None]] = None,\n) -&gt; None:\n    \"\"\"\n    Recursively scans the root_path and writes every file and folder\n    with its full path into a structured markdown file.\n\n    Args:\n        root_path: Path to the backup directory to scan.\n        output_file: Path to the output markdown file.\n        callback: Optional callback function called with (count, current_root).\n\n    Raises:\n        FileNotFoundError: If root_path does not exist.\n        NotADirectoryError: If root_path is not a directory.\n        PermissionError: If output_file cannot be written.\n    \"\"\"\n    root_path = Path(root_path).resolve()\n    if not root_path.exists():\n        raise FileNotFoundError(f\"Backup path does not exist: {root_path}\")\n    if not root_path.is_dir():\n        raise NotADirectoryError(f\"Backup path is not a directory: {root_path}\")\n\n    output_path = Path(output_file)\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n\n    try:\n        label = get_volume_label(root_path)\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(\"# Backup Index\\n\\n\")\n            root_line = f\"Root: {root_path}\"\n            if label:\n                root_line += f\" (Label: {label})\"\n            f.write(f\"{root_line}\\n\\n\")\n\n            count = 0\n            for root, dirs, files in tqdm(os.walk(root_path), desc=\"Scanning directories\"):\n                count += 1\n                if callback:\n                    callback(count, root)\n                current_path = Path(root)\n                f.write(f\"## {current_path}\\n\\n\")\n\n                for d in sorted(dirs):\n                    f.write(f\"- {current_path / d}/\\n\")\n                for name in sorted(files):\n                    file_path = current_path / name\n                    try:\n                        mtime = os.path.getmtime(file_path)\n                        f.write(f\"- {file_path} | mtime:{mtime}\\n\")\n                    except Exception:\n                        f.write(f\"- {file_path}\\n\")\n                f.write(\"\\n\")\n    except PermissionError as e:\n        raise PermissionError(f\"Cannot write to output file: {output_path}\") from e\n</code></pre>"},{"location":"api/#semantic_backup_explorer.rag.rag_pipeline","title":"<code>semantic_backup_explorer.rag.rag_pipeline</code>","text":"<p>Module for the RAG (Retrieval-Augmented Generation) pipeline.</p>"},{"location":"api/#semantic_backup_explorer.rag.rag_pipeline-classes","title":"Classes","text":""},{"location":"api/#semantic_backup_explorer.rag.rag_pipeline.RAGPipeline","title":"<code>RAGPipeline</code>","text":"<p>Orchestrates the retrieval and generation process to answer questions about backups.</p> Source code in <code>semantic_backup_explorer/rag/rag_pipeline.py</code> <pre><code>class RAGPipeline:\n    \"\"\"\n    Orchestrates the retrieval and generation process to answer questions about backups.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the RAG pipeline with embedder, retriever, and LLM client.\n\n        Raises:\n            ImportError: If any semantic dependencies are missing.\n        \"\"\"\n        if not HAS_LLM_CLIENT:\n            raise ImportError(\"llm-client is not installed. Please install it with 'pip install -e .[semantic]'\")\n        self.embedder = Embedder()\n        self.retriever = Retriever()\n        # Default to groq as requested\n        self.client = LLMClient(api_choice=\"groq\")\n\n    def answer_question(self, question: str) -&gt; tuple[str, str]:\n        \"\"\"\n        Answers a question using retrieved context from the backup index.\n\n        Args:\n            question: The user's question.\n\n        Returns:\n            A tuple of (answer_text, context_text).\n        \"\"\"\n        # 1. Embed question\n        query_embedding = self.embedder.embed_query(question)\n\n        # 2. Retrieve relevant chunks\n        results = self.retriever.query(query_embedding, n_results=3)\n\n        documents = results.get(\"documents\")\n        if documents and len(documents) &gt; 0:\n            doc_list = documents[0]\n            if doc_list:\n                context = \"\\n\\n\".join(doc_list)\n            else:\n                context = \"\"\n        else:\n            context = \"\"\n\n        # 3. Generate answer\n        prompt = f\"\"\"\nDu bist ein hilfreicher Assistent f\u00fcr die Suche in Backup-Strukturen.\nBasierend auf den folgenden Informationen aus dem Backup-Index, beantworte die Frage des Nutzers.\nWenn die Information nicht im Kontext enthalten ist, sage dass du es nicht wei\u00dft.\n\nKontext:\n{context}\n\nFrage: {question}\n\nAntwort:\"\"\"\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"Du bist ein Backup-Explorer Assistent.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n\n        response = self.client.chat_completion(messages)\n        return response, context\n</code></pre>"},{"location":"api/#semantic_backup_explorer.rag.rag_pipeline.RAGPipeline-functions","title":"Functions","text":""},{"location":"api/#semantic_backup_explorer.rag.rag_pipeline.RAGPipeline.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the RAG pipeline with embedder, retriever, and LLM client.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If any semantic dependencies are missing.</p> Source code in <code>semantic_backup_explorer/rag/rag_pipeline.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the RAG pipeline with embedder, retriever, and LLM client.\n\n    Raises:\n        ImportError: If any semantic dependencies are missing.\n    \"\"\"\n    if not HAS_LLM_CLIENT:\n        raise ImportError(\"llm-client is not installed. Please install it with 'pip install -e .[semantic]'\")\n    self.embedder = Embedder()\n    self.retriever = Retriever()\n    # Default to groq as requested\n    self.client = LLMClient(api_choice=\"groq\")\n</code></pre>"},{"location":"api/#semantic_backup_explorer.rag.rag_pipeline.RAGPipeline.answer_question","title":"<code>answer_question(question)</code>","text":"<p>Answers a question using retrieved context from the backup index.</p> <p>Parameters:</p> Name Type Description Default <code>question</code> <code>str</code> <p>The user's question.</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>A tuple of (answer_text, context_text).</p> Source code in <code>semantic_backup_explorer/rag/rag_pipeline.py</code> <pre><code>    def answer_question(self, question: str) -&gt; tuple[str, str]:\n        \"\"\"\n        Answers a question using retrieved context from the backup index.\n\n        Args:\n            question: The user's question.\n\n        Returns:\n            A tuple of (answer_text, context_text).\n        \"\"\"\n        # 1. Embed question\n        query_embedding = self.embedder.embed_query(question)\n\n        # 2. Retrieve relevant chunks\n        results = self.retriever.query(query_embedding, n_results=3)\n\n        documents = results.get(\"documents\")\n        if documents and len(documents) &gt; 0:\n            doc_list = documents[0]\n            if doc_list:\n                context = \"\\n\\n\".join(doc_list)\n            else:\n                context = \"\"\n        else:\n            context = \"\"\n\n        # 3. Generate answer\n        prompt = f\"\"\"\nDu bist ein hilfreicher Assistent f\u00fcr die Suche in Backup-Strukturen.\nBasierend auf den folgenden Informationen aus dem Backup-Index, beantworte die Frage des Nutzers.\nWenn die Information nicht im Kontext enthalten ist, sage dass du es nicht wei\u00dft.\n\nKontext:\n{context}\n\nFrage: {question}\n\nAntwort:\"\"\"\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"Du bist ein Backup-Explorer Assistent.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n\n        response = self.client.chat_completion(messages)\n        return response, context\n</code></pre>"},{"location":"api/#semantic_backup_explorer.compare.folder_diff","title":"<code>semantic_backup_explorer.compare.folder_diff</code>","text":"<p>Module for comparing local folders with backup contents.</p>"},{"location":"api/#semantic_backup_explorer.compare.folder_diff-classes","title":"Classes","text":""},{"location":"api/#semantic_backup_explorer.compare.folder_diff.FolderDiffResult","title":"<code>FolderDiffResult</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Result of folder comparison.</p> Source code in <code>semantic_backup_explorer/compare/folder_diff.py</code> <pre><code>class FolderDiffResult(TypedDict):\n    \"\"\"Result of folder comparison.\"\"\"\n\n    only_local: list[str]\n    only_backup: list[str]\n    in_both: list[str]\n</code></pre>"},{"location":"api/#semantic_backup_explorer.compare.folder_diff-functions","title":"Functions","text":""},{"location":"api/#semantic_backup_explorer.compare.folder_diff.compare_folders","title":"<code>compare_folders(local_path, backup_files)</code>","text":"<p>Compares local folder content with backup files.</p> <p>Files with newer local modification times are included in 'only_local' to trigger sync.</p> <p>Parameters:</p> Name Type Description Default <code>local_path</code> <code>str | Path</code> <p>Path to the local folder.</p> required <code>backup_files</code> <code>Union[list[str], dict[str, float]]</code> <p>Either a list of relative paths or a dictionary mapping          relative paths to modification timestamps.</p> required <p>Returns:</p> Type Description <code>FolderDiffResult</code> <p>A TypedDict containing lists of files 'only_local', 'only_backup', and 'in_both'.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If local_path does not exist.</p> <code>NotADirectoryError</code> <p>If local_path is not a directory.</p> Source code in <code>semantic_backup_explorer/compare/folder_diff.py</code> <pre><code>def compare_folders(local_path: str | Path, backup_files: Union[list[str], dict[str, float]]) -&gt; FolderDiffResult:\n    \"\"\"\n    Compares local folder content with backup files.\n\n    Files with newer local modification times are included in 'only_local' to trigger sync.\n\n    Args:\n        local_path: Path to the local folder.\n        backup_files: Either a list of relative paths or a dictionary mapping\n                     relative paths to modification timestamps.\n\n    Returns:\n        A TypedDict containing lists of files 'only_local', 'only_backup', and 'in_both'.\n\n    Raises:\n        FileNotFoundError: If local_path does not exist.\n        NotADirectoryError: If local_path is not a directory.\n    \"\"\"\n    local_path = Path(local_path)\n    if not local_path.exists():\n        raise FileNotFoundError(f\"Local path does not exist: {local_path}\")\n    if not local_path.is_dir():\n        raise NotADirectoryError(f\"Local path is not a directory: {local_path}\")\n\n    local_files_dict = get_folder_content(local_path)\n    local_paths = set(local_files_dict.keys())\n\n    if isinstance(backup_files, dict):\n        backup_paths = set(backup_files.keys())\n    else:\n        backup_paths = set(backup_files)\n\n    only_local = local_paths - backup_paths\n    only_backup = backup_paths - local_paths\n    in_both = local_paths &amp; backup_paths\n\n    # Check for newer files in local\n    newer_locally = set()\n    if isinstance(backup_files, dict):\n        for path in in_both:\n            local_mtime = local_files_dict.get(path, 0.0)\n            backup_mtime = backup_files.get(path, 0.0)\n            # Use a small epsilon for float comparison (0.1 seconds)\n            if local_mtime &gt; backup_mtime + 0.1:\n                newer_locally.add(path)\n\n    only_local.update(newer_locally)\n    in_both = in_both - newer_locally\n\n    return {\"only_local\": sorted(list(only_local)), \"only_backup\": sorted(list(only_backup)), \"in_both\": sorted(list(in_both))}\n</code></pre>"},{"location":"api/#semantic_backup_explorer.compare.folder_diff.get_folder_content","title":"<code>get_folder_content(folder_path)</code>","text":"<p>Returns a dictionary of relative file paths and their modification times.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str | Path</code> <p>Path to the folder to scan.</p> required <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Dictionary mapping relative file paths to their modification timestamps.</p> Source code in <code>semantic_backup_explorer/compare/folder_diff.py</code> <pre><code>def get_folder_content(folder_path: str | Path) -&gt; dict[str, float]:\n    \"\"\"\n    Returns a dictionary of relative file paths and their modification times.\n\n    Args:\n        folder_path: Path to the folder to scan.\n\n    Returns:\n        Dictionary mapping relative file paths to their modification timestamps.\n    \"\"\"\n    folder_path = Path(folder_path)\n    if not folder_path.exists():\n        return {}\n\n    files: dict[str, float] = {}\n    for root, _, filenames in os.walk(folder_path):\n        for f in filenames:\n            full_path = Path(root) / f\n            rel_path = str(full_path.relative_to(folder_path))\n            try:\n                files[rel_path] = os.path.getmtime(full_path)\n            except Exception:\n                files[rel_path] = 0.0\n    return files\n</code></pre>"},{"location":"api/#semantic_backup_explorer.sync.sync_missing","title":"<code>semantic_backup_explorer.sync.sync_missing</code>","text":"<p>Module for synchronizing files between local and backup directories.</p>"},{"location":"api/#semantic_backup_explorer.sync.sync_missing-classes","title":"Classes","text":""},{"location":"api/#semantic_backup_explorer.sync.sync_missing.SyncProgressCallback","title":"<code>SyncProgressCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for sync progress callbacks.</p> Source code in <code>semantic_backup_explorer/sync/sync_missing.py</code> <pre><code>class SyncProgressCallback(Protocol):\n    \"\"\"Protocol for sync progress callbacks.\"\"\"\n\n    def __call__(self, current: int, total: int, filename: str, error: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Called for each file processed.\n\n        Args:\n            current: Current file number (1-indexed).\n            total: Total number of files.\n            filename: Relative path of current file.\n            error: Error message if sync failed, None if successful.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/#semantic_backup_explorer.sync.sync_missing.SyncProgressCallback-functions","title":"Functions","text":""},{"location":"api/#semantic_backup_explorer.sync.sync_missing.SyncProgressCallback.__call__","title":"<code>__call__(current, total, filename, error=None)</code>","text":"<p>Called for each file processed.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>int</code> <p>Current file number (1-indexed).</p> required <code>total</code> <code>int</code> <p>Total number of files.</p> required <code>filename</code> <code>str</code> <p>Relative path of current file.</p> required <code>error</code> <code>Optional[str]</code> <p>Error message if sync failed, None if successful.</p> <code>None</code> Source code in <code>semantic_backup_explorer/sync/sync_missing.py</code> <pre><code>def __call__(self, current: int, total: int, filename: str, error: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Called for each file processed.\n\n    Args:\n        current: Current file number (1-indexed).\n        total: Total number of files.\n        filename: Relative path of current file.\n        error: Error message if sync failed, None if successful.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#semantic_backup_explorer.sync.sync_missing-functions","title":"Functions","text":""},{"location":"api/#semantic_backup_explorer.sync.sync_missing.sync_files","title":"<code>sync_files(files_to_sync, source_root, target_root, callback=None)</code>","text":"<p>Copies files from source_root to target_root.</p> <p>Parameters:</p> Name Type Description Default <code>files_to_sync</code> <code>list[str]</code> <p>List of relative file paths to copy.</p> required <code>source_root</code> <code>str | Path</code> <p>Source directory.</p> required <code>target_root</code> <code>str | Path</code> <p>Target directory.</p> required <code>callback</code> <code>Optional[SyncProgressCallback]</code> <p>Optional progress callback.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[str], list[tuple[str, str]]]</code> <p>Tuple of (synced_files, errors) where errors is a list of (filename, error_msg).</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If source_root does not exist.</p> Source code in <code>semantic_backup_explorer/sync/sync_missing.py</code> <pre><code>def sync_files(\n    files_to_sync: list[str], source_root: str | Path, target_root: str | Path, callback: Optional[SyncProgressCallback] = None\n) -&gt; tuple[list[str], list[tuple[str, str]]]:\n    \"\"\"\n    Copies files from source_root to target_root.\n\n    Args:\n        files_to_sync: List of relative file paths to copy.\n        source_root: Source directory.\n        target_root: Target directory.\n        callback: Optional progress callback.\n\n    Returns:\n        Tuple of (synced_files, errors) where errors is a list of (filename, error_msg).\n\n    Raises:\n        FileNotFoundError: If source_root does not exist.\n    \"\"\"\n    source_root = Path(source_root)\n    target_root = Path(target_root)\n\n    if not source_root.exists():\n        raise FileNotFoundError(f\"Source root does not exist: {source_root}\")\n\n    synced = []\n    errors = []\n    total = len(files_to_sync)\n\n    for i, rel_path in enumerate(files_to_sync):\n        src = source_root / rel_path\n        dst = target_root / rel_path\n\n        error_msg = None\n        try:\n            # Create target directory if it doesn't exist\n            dst.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy2(src, dst)\n            synced.append(rel_path)\n        except Exception as e:\n            error_msg = str(e)\n            errors.append((rel_path, error_msg))\n\n        if callback:\n            callback(i + 1, total, rel_path, error_msg)\n\n    return synced, errors\n</code></pre>"},{"location":"api/#semantic_backup_explorer.utils.config","title":"<code>semantic_backup_explorer.utils.config</code>","text":"<p>Centralized configuration for backup operations.</p>"},{"location":"api/#semantic_backup_explorer.utils.config-classes","title":"Classes","text":""},{"location":"api/#semantic_backup_explorer.utils.config.BackupConfig","title":"<code>BackupConfig</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Central configuration for backup operations.</p> <p>Loads values from environment variables or a .env file.</p> Source code in <code>semantic_backup_explorer/utils/config.py</code> <pre><code>class BackupConfig(BaseSettings):  # type: ignore[misc]\n    \"\"\"\n    Central configuration for backup operations.\n\n    Loads values from environment variables or a .env file.\n    \"\"\"\n\n    backup_drive: Path = Path(\"/media/backup\")\n    index_path: Path = Path(\"data/backup_index.md\")\n    embeddings_path: Path = Path(\"data/embeddings\")\n    groq_api_key: str = \"\"\n\n    model_config = SettingsConfigDict(env_file=\".env\", env_file_encoding=\"utf-8\", extra=\"ignore\")\n\n    def validate_backup_drive(self) -&gt; None:\n        \"\"\"\n        Validate that backup drive exists and is accessible.\n\n        Raises:\n            ValueError: If backup drive does not exist.\n        \"\"\"\n        if not self.backup_drive.exists():\n            raise ValueError(f\"Backup drive not found: {self.backup_drive}\")\n</code></pre>"},{"location":"api/#semantic_backup_explorer.utils.config.BackupConfig-functions","title":"Functions","text":""},{"location":"api/#semantic_backup_explorer.utils.config.BackupConfig.validate_backup_drive","title":"<code>validate_backup_drive()</code>","text":"<p>Validate that backup drive exists and is accessible.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If backup drive does not exist.</p> Source code in <code>semantic_backup_explorer/utils/config.py</code> <pre><code>def validate_backup_drive(self) -&gt; None:\n    \"\"\"\n    Validate that backup drive exists and is accessible.\n\n    Raises:\n        ValueError: If backup drive does not exist.\n    \"\"\"\n    if not self.backup_drive.exists():\n        raise ValueError(f\"Backup drive not found: {self.backup_drive}\")\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>This document describes the high-level architecture of the Semantic Backup Explorer.</p>"},{"location":"architecture/#overview","title":"Overview","text":"<p>The project is a RAG (Retrieval-Augmented Generation) based system designed to help users search through their file backups and synchronize local changes.</p>"},{"location":"architecture/#components","title":"Components","text":""},{"location":"architecture/#1-library-semantic_backup_explorer","title":"1. Library (<code>semantic_backup_explorer/</code>)","text":"<ul> <li><code>core/</code>: Contains the main business logic (<code>BackupOperations</code>). It orchestrates folder finding and comparison.</li> <li><code>rag/</code>: Implements the RAG pipeline using <code>SentenceTransformers</code> for embeddings and <code>ChromaDB</code> for vector storage. It uses <code>llm_client</code> to interface with Groq.</li> <li><code>indexer/</code>: Handles the recursive scanning of backup directories and produces a Markdown index file.</li> <li><code>chunking/</code>: Partitions the Markdown index into folder-based chunks suitable for the vector database.</li> <li><code>compare/</code>: Logic for comparing local directory contents with the backup index, considering both existence and modification times.</li> <li><code>sync/</code>: Handles the actual copying of files from source to destination.</li> <li><code>utils/</code>: Shared utilities for configuration, logging, path normalization, and compatibility.</li> </ul>"},{"location":"architecture/#2-cli-ui-semantic_backup_explorercli","title":"2. CLI &amp; UI (<code>semantic_backup_explorer/cli/</code>)","text":"<ul> <li><code>ui/gradio_app.py</code>: A web interface built with Gradio for an interactive experience.</li> <li><code>commands/</code>: (Future) Place for modular CLI commands.</li> </ul>"},{"location":"architecture/#3-scripts-scripts","title":"3. Scripts (<code>scripts/</code>)","text":"<p>Standalone Python scripts for common tasks: - <code>auto_sync.py</code>: Automated synchronization based on a config file. - <code>build_index.py</code>: Scans a backup drive and builds the vector database.</p>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<ol> <li>Scanning: <code>indexer</code> scans the backup drive -&gt; <code>backup_index.md</code>.</li> <li>Indexing: <code>chunking</code> reads <code>backup_index.md</code> -&gt; <code>rag.Embedder</code> creates vectors -&gt; <code>rag.Retriever</code> stores in <code>ChromaDB</code>.</li> <li>Search: User query -&gt; <code>rag.Embedder</code> -&gt; <code>rag.Retriever</code> (context) -&gt; <code>llm_client</code> (Groq) -&gt; Answer.</li> <li>Compare &amp; Sync: Local folder -&gt; <code>core.BackupOperations</code> finds backup counterpart (keyword or RAG) -&gt; <code>compare</code> identifies differences -&gt; <code>sync</code> copies files.</li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>The Semantic Backup Explorer uses environment variables and a centralized configuration class for management.</p>"},{"location":"configuration/#central-configuration-backupconfig","title":"Central Configuration (<code>BackupConfig</code>)","text":"<p>The <code>BackupConfig</code> class in <code>semantic_backup_explorer/utils/config.py</code> defines the default settings:</p> <ul> <li><code>backup_drive</code>: The root path of your backup drive (default: <code>/media/backup</code>).</li> <li>Drive Labels (Windows): The indexer automatically detects the volume label of your drive on Windows. This information is included in the index to provide better context for the KI search.</li> <li><code>index_path</code>: Path to the generated Markdown index file (default: <code>data/backup_index.md</code>).</li> <li><code>embeddings_path</code>: Directory for ChromaDB storage (default: <code>data/embeddings</code>).</li> <li><code>groq_api_key</code>: Your Groq API key for the RAG pipeline.</li> </ul>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>You can override these defaults by creating a <code>.env</code> file in the project root:</p> <pre><code>BACKUP_DRIVE=/path/to/my/external/drive\nINDEX_PATH=data/my_backup.md\nEMBEDDINGS_PATH=data/my_embeddings\nGROQ_API_KEY=gsk_your_key_here\n</code></pre>"},{"location":"configuration/#backup-configuration-backup_configmd","title":"Backup Configuration (<code>backup_config.md</code>)","text":"<p>For the <code>auto_sync.py</code> script, you define which local folders should be tracked in a Markdown file:</p> <pre><code>## Source Folders\n- /home/user/Documents\n- /home/user/Pictures/2023\n</code></pre> <p>The script will attempt to find a matching folder on the backup drive for each entry listed here.</p>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide provides examples for both the CLI scripts and the Web UI.</p>"},{"location":"usage/#initial-setup","title":"Initial Setup","text":"<p>Before using the tool, you must create an index of your backup drive:</p> <pre><code>python scripts/build_index.py --path /media/external_backup\n</code></pre> <p>This command will: 1. Scan the drive and create <code>data/backup_index.md</code>. 2. Generate embeddings and store them in the vector database.</p>"},{"location":"usage/#web-interface","title":"Web Interface","text":"<p>Start the Gradio app:</p> <pre><code>python -m semantic_backup_explorer.cli.ui.gradio_app\n</code></pre> <p>Navigate to <code>http://localhost:7860</code> in your browser.</p> <ul> <li>One-Click Sync:<ol> <li>Klicke auf \"Ordner w\u00e4hlen\" und suche den lokalen Ordner aus, den du abgleichen m\u00f6chtest.</li> <li>Klicke auf \"Vergleichen\". Die App vergleicht deinen lokalen Ordner mit den Daten aus der <code>backup_index.md</code>.</li> <li>Die App sucht automatisch das passende Gegenst\u00fcck auf deinem Backup-Laufwerk (basierend auf dem Namen oder via KI-Suche falls installiert).</li> <li>In der Liste \"Nur Lokal\" siehst du alle Dateien, die noch nicht im Backup sind oder lokal neuer sind.</li> <li>Klicke auf Synchronisieren, um die fehlenden Dateien direkt auf die externe Festplatte zu kopieren.</li> </ol> </li> </ul>"},{"location":"usage/#sicherheit-mehrere-laufwerke","title":"\ud83d\udee1\ufe0f Sicherheit &amp; Mehrere Laufwerke","text":"<p>Die App nutzt den Volume Namen (Label) deiner Festplatte zur Identifizierung. Dies ist besonders wichtig, wenn du mehrere externe Platten hast, die sich unter demselben Laufwerksbuchstaben (z.B. <code>J:\\</code>) anmelden.</p> <ul> <li>Verifikation vor Sync: Vor jeder Synchronisation pr\u00fcft die App, ob das aktuell angeschlossene Laufwerk denselben Namen hat wie das Laufwerk, f\u00fcr das der Index erstellt wurde. Bei einem Konflikt bricht die App ab, um Fehlkopien zu vermeiden.</li> <li>Index-Aktualit\u00e4t: Der Abgleich erfolgt blitzschnell gegen den gespeicherten Index. Wenn der Index \u00e4lter als 7 Tage ist, gibt die App eine Warnung aus. Aktualisiere den Index im Tab Index Viewer, wenn du Dateien manuell auf der Festplatte ge\u00e4ndert hast.</li> <li>Index Viewer: Verwalte hier deine Backup-Indizes. Du kannst ein Laufwerk scannen, um eine kompakte Liste aller Dateien zu erstellen.</li> <li>Semantic Search (Optional): Nutze nat\u00fcrliche Sprache. Frage z.B. \"Wo liegen meine alten Steuererkl\u00e4rungen?\". Die KI durchsucht den Index und nennt dir die wahrscheinlichsten Ordner.</li> </ul>"},{"location":"usage/#schritt-fur-schritt-fur-einsteiger","title":"Schritt-f\u00fcr-Schritt f\u00fcr Einsteiger","text":""},{"location":"usage/#1-vorbereitung","title":"1. Vorbereitung","text":"<p>Schlie\u00dfe dein Backup-Laufwerk (z.B. eine USB-Festplatte) an deinen Computer an.</p>"},{"location":"usage/#2-den-index-erstellen-einmalig-pro-laufwerk","title":"2. Den Index erstellen (Einmalig pro Laufwerk)","text":"<p>Gehe zum Tab Index Viewer. W\u00e4hle \u00fcber den Button \"Ordner w\u00e4hlen\" dein Backup-Laufwerk aus (z.B. <code>E:\\</code>). Klicke auf Index erstellen. Die App scannt nun alle Dateien. Das kann je nach Gr\u00f6\u00dfe der Festplatte ein paar Minuten dauern.</p>"},{"location":"usage/#3-sichern-mit-one-click-sync","title":"3. Sichern mit One-Click Sync","text":"<p>Gehe zum Tab One-Click Sync. W\u00e4hle deinen lokalen Ordner (den du sichern willst) aus und klicke auf Vergleichen. Die App zeigt dir, was gesichert werden muss. Klicke dann auf Synchronisieren.</p>"},{"location":"usage/#4-ki-suche-aktivieren-optional","title":"4. KI-Suche aktivieren (Optional)","text":"<p>Falls du die semantischen Features installiert hast, gehe zum Tab Semantic Search. Klicke auf den Button Embeddings erstellen. Dies muss nur einmal nach dem Erstellen eines neuen Index gemacht werden, damit die KI die Ordnerstruktur \"verstehen\" kann.</p>"},{"location":"usage/#automated-sync","title":"Automated Sync","text":"<p>To sync all folders defined in your <code>backup_config.md</code>:</p> <pre><code>python scripts/auto_sync.py --backup_path /media/external_backup\n</code></pre> <p>This script will: 1. Re-scan the backup drive to ensure the index is up-to-date. 2. Iterate through each source folder. 3. Compare and copy missing files. 4. Print a summary protocol at the end.</p>"},{"location":"usage/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>No matching folder found: Ensure the local folder name is reasonably similar to the folder name in the backup.</li> <li>RAG Errors: Check your <code>GROQ_API_KEY</code> in the <code>.env</code> file.</li> <li>Stale Embeddings: If you manually edited files on the backup, rebuild the index via the UI or <code>build_index.py</code>.</li> </ul>"}]}